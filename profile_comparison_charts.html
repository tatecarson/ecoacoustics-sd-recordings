<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Geophony Profile Comparison — Charts</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #f7f9fb;
      --card: #ffffff;
      --text: #2c3e50;
      --muted: #6b7b8c;
      --accent: #3498db;
      --border: #e1e8f0;
    }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.45;
    }
    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px 20px 28px;
    }
    h1, h2, h3 {
      margin: 0 0 10px 0;
    }
    h1 {
      font-size: 24px;
      margin-bottom: 12px;
    }
    .intro {
      color: var(--muted);
      margin-bottom: 16px;
      font-size: 14px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 14px;
      margin-bottom: 14px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.04);
    }
    .weights-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .weights-table th, .weights-table td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      text-align: right;
    }
    .weights-table th:first-child, .weights-table td:first-child {
      text-align: left;
    }
    .legend {
      color: var(--muted);
      font-size: 12px;
      margin-top: 6px;
    }
    .muted {
      color: var(--muted);
      font-size: 12px;
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 12px;
    }
    .footer-note {
      color: var(--muted);
      font-size: 12px;
      margin-top: 16px;
    }
    .path-note {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background: #f1f5f9;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px;
      color: #334155;
      overflow-x: auto;
      font-size: 12px;
    }
    /* Tabs */
    .tabs {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }
    .tab {
      background: #eef2f6;
      color: #1f2937;
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
    }
    .tab.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    /* Fixed chart height to keep page compact */
    .chart-wrap {
      height: 180px; /* compact */
      position: relative;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>Geophony Profile Comparison — Charts</h1>
    <p class="intro">
      Visualize how many beams each profile exported per sound type, with quick stats. This page reads the same outputs used by the audio comparison page and summarizes them as charts.
    </p>

    <div class="card">
      <h2>Profile Weights</h2>
      <table class="weights-table" id="weights-table">
        <thead>
          <tr>
            <th>Profile</th>
            <th>Hf</th>
            <th>ADI</th>
            <th>1−Ht</th>
            <th>ACI</th>
            <th>Spatial</th>
          </tr>
        </thead>
        <tbody id="weights-tbody"></tbody>
      </table>
      <div class="legend">
        Hf = spectral entropy (activity), ADI = frequency diversity, 1−Ht = temporal complexity (lower Ht → higher complexity), ACI = acoustic complexity, Spatial = 1 − mean(|corr|) to other beams.<br />
        If you update config profile weights, mirror changes here.
      </div>
    </div>

    <div class="card">
      <h2>Overview</h2>
      <div class="muted">
        For each (profile, sound type), this page:
        <ul>
          <li>Finds the analysis folder by probing for <code>analysis_report.html</code> under <code>out_<profile>/<soundType>/<candidate>/</code> (candidates: general-geo, none, water-flow, wind, then the soundType, then the profile).</li>
          <li>Prefers <code>maad_indices.csv</code> (exported/selected) and falls back to <code>maad_indices_all_directions.csv</code>.</li>
          <li>Counts exported beams and computes basic stats (mean total_score if present).</li>
        </ul>
      </div>
      <div class="path-note">Example path resolution that is supported: <code>out_rain/wind/wind/maad_indices.csv</code> (auto-detected leaf "wind").</div>
    </div>

    <div class="row">
      <div class="card">
        <h3>Aggregate — Exported Beams per Profile (All Sound Types)</h3>
        <div class="chart-wrap"><canvas id="aggregateChart"></canvas></div>
        <div id="aggregateNote" class="muted"></div>
      </div>
      <div class="card">
        <h3>Analyzed vs Exported (All Sound Types)</h3>
        <div class="chart-wrap"><canvas id="coverageChart"></canvas></div>
        <div class="muted">Shows total analyzed beams (all_directions) vs exported (selected). Useful to see coverage and selection rate.</div>
      </div>
    </div>

    <!-- Focus block: single selector + one chart for the chosen sound type -->
    <div class="card">
      <h2>Focus: Beams by Profile for Selected Sound Type</h2>
      <div class="row" style="grid-template-columns: 1fr 1fr;">
        <div>
          <label class="muted" for="soundTypeSelect">Sound type</label>
          <select id="soundTypeSelect" style="display:block; margin:6px 0 8px; padding:6px 8px; border:1px solid var(--border); border-radius:6px;">
            <!-- options injected by JS -->
          </select>
          <div class="chart-wrap"><canvas id="focusChart"></canvas></div>
          <div class="muted" id="focusNote">Colored bars = exported (selected). Light overlay line = selection rate (exported/analyzed).</div>
        </div>
        <div>
          <h3 style="margin-top:0;">Summary</h3>
          <table class="weights-table" id="summaryTable">
            <thead>
              <tr>
                <th style="text-align:left;">Profile</th>
                <th>Exported</th>
                <th>Analyzed</th>
                <th>Rate %</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
          <div class="legend">Click a row to highlight the corresponding bar.</div>
        </div>
      </div>
    </div>

    <!-- Collapsible aggregate section to reduce page length -->
    <details class="card">
      <summary><strong>Aggregate (all sound types)</strong> — collapsed</summary>
      <div class="row" style="margin-top:10px;">
        <div class="card">
          <h3>Exported Beams per Profile (Sum)</h3>
          <div class="chart-wrap"><canvas id="aggregateChart2"></canvas></div>
        </div>
        <div class="card">
          <h3>Analyzed vs Exported (Sum)</h3>
          <div class="chart-wrap"><canvas id="coverageChart2"></canvas></div>
        </div>
      </div>
    </details>

    <div class="footer-note">
      Data loaded via static fetch(). If a CSV is missing for a given combination, exported=0 and analyzed=0 are shown.
    </div>
  </div>

  <script>
    // Profiles and sound types to display (consistent with audio page)
    const profiles = ['wind', 'rain', 'surf_river', 'thunder', 'geophony_general', 'none'];
    const soundTypes = ['general-geo', 'none', 'water-flow', 'wind'];

    // Profile weight constants (keep in sync with config)
    const weightsMap = {
      wind:             { Hf: 0.15, ADI: 0.10, TEMP: 0.30, ACI: 0.15, SPATIAL: 0.30 },
      rain:             { Hf: 0.10, ADI: 0.15, TEMP: 0.30, ACI: 0.10, SPATIAL: 0.35 },
      surf_river:       { Hf: 0.10, ADI: 0.30, TEMP: 0.10, ACI: 0.20, SPATIAL: 0.30 },
      thunder:          { Hf: 0.05, ADI: 0.05, TEMP: 0.40, ACI: 0.15, SPATIAL: 0.35 },
      geophony_general: { Hf: 0.10, ADI: 0.20, TEMP: 0.30, ACI: 0.10, SPATIAL: 0.30 },
      none:             { Hf: 0.10, ADI: 0.20, TEMP: 0.30, ACI: 0.10, SPATIAL: 0.30 }
    };

    // Render weights table
    function renderWeights() {
      const tbody = document.getElementById('weights-tbody');
      tbody.innerHTML = profiles.map(p => {
        const w = weightsMap[p];
        return `
          <tr>
            <td>${p}</td>
            <td>${w.Hf.toFixed(2)}</td>
            <td>${w.ADI.toFixed(2)}</td>
            <td>${w.TEMP.toFixed(2)}</td>
            <td>${w.ACI.toFixed(2)}</td>
            <td>${w.SPATIAL.toFixed(2)}</td>
          </tr>
        `;
      }).join('');
    }

    // Auto-detect input_stem (analysis folder) by probing analysis_report.html
    const _stemCache = new Map();
    async function detectStem(profile, soundType) {
      const key = profile + '::' + soundType;
      if (_stemCache.has(key)) return _stemCache.get(key);
      const candidates = ['general-geo', 'none', 'water-flow', 'wind'];
      if (!candidates.includes(soundType)) candidates.push(soundType);
      if (!candidates.includes(profile)) candidates.push(profile);
      for (const c of candidates) {
        const url = `out_${profile}/${soundType}/${c}/analysis_report.html`;
        try {
          const head = await fetch(url, { method: 'HEAD', cache: 'no-cache' });
          if (head.ok) { _stemCache.set(key, c); return c; }
        } catch(e) {}
        try {
          const get = await fetch(url, { cache: 'no-cache' });
          if (get.ok) { _stemCache.set(key, c); return c; }
        } catch(e) {}
      }
      _stemCache.set(key, soundType);
      return soundType;
    }

    // Fetch CSV and parse (simple CSV, no quoted commas)
    async function fetchCsv(url) {
      try {
        const res = await fetch(url, { cache: 'no-cache' });
        if (!res.ok) return [];
        const text = await res.text();
        const lines = text.trim().split(/\r?\n/);
        if (!lines.length) return [];
        const headers = lines[0].split(',').map(h => h.trim());
        return lines.slice(1).map(line => {
          const cols = line.split(',').map(c => c.trim());
          const obj = {};
          headers.forEach((h, i) => obj[h] = cols[i] ?? '');
          return obj;
        });
      } catch(e) {
        return [];
      }
    }

    // Load metrics for a profile/soundType
    async function loadMetrics(profile, soundType) {
      const stem = await detectStem(profile, soundType);

      // Heuristic: try base folder first (no stem), then detected stem folder
      const baseNoStem = `out_${profile}/${soundType}`;
      const baseWithStem = `out_${profile}/${soundType}/${stem}`;

      // Try exported (selected) CSVs
      let exported = await fetchCsv(`${baseNoStem}/maad_indices.csv`);
      if (!exported.length) {
        exported = await fetchCsv(`${baseWithStem}/maad_indices.csv`);
      }
      // Try analyzed (all-directions) CSVs
      let analyzed = await fetchCsv(`${baseNoStem}/maad_indices_all_directions.csv`);
      if (!analyzed.length) {
        analyzed = await fetchCsv(`${baseWithStem}/maad_indices_all_directions.csv`);
      }

      const exportedCount = exported.length;
      const analyzedCount = analyzed.length;

      // Compute basic stats on exported if present
      let meanTotal = null;
      if (exportedCount && 'total_score' in (exported[0] || {})) {
        const vals = exported.map(r => parseFloat(r.total_score)).filter(x => Number.isFinite(x));
        if (vals.length) {
          meanTotal = vals.reduce((a,b) => a+b, 0) / vals.length;
        }
      }
      return { profile, soundType, exportedCount, analyzedCount, meanTotal };
    }

    // Colors per profile
    const profileColors = {
      wind: '#1f77b4',
      rain: '#2ca02c',
      surf_river: '#ff7f0e',
      thunder: '#d62728',
      geophony_general: '#9467bd',
      none: '#7f7f7f'
    };

    // Populate sound type selector (replaces tabs)
    function buildSoundTypeSelect() {
      const sel = document.getElementById('soundTypeSelect');
      if (!sel) return;
      sel.innerHTML = soundTypes.map(st => `<option value="${st}">${st}</option>`).join('');
    }

    async function init() {
      renderWeights();
      buildSoundTypeSelect();

      // Load all metrics for all combinations
      const allPromises = [];
      for (const st of soundTypes) {
        for (const p of profiles) {
          allPromises.push(loadMetrics(p, st));
        }
      }
      const results = await Promise.all(allPromises);

      // Aggregate counters
      const exportedByProfile = Object.fromEntries(profiles.map(p => [p, 0]));
      const analyzedByProfile = Object.fromEntries(profiles.map(p => [p, 0]));

      // Organize by soundType
      const bySoundType = {};
      soundTypes.forEach(st => bySoundType[st] = results.filter(r => r.soundType === st));

      // Precompute per-soundType datasets and update aggregates
      const perSoundTypeData = {};
      for (const st of soundTypes) {
        const rows = bySoundType[st];
        const labels = profiles;
        const exportedData = labels.map(p => (rows.find(r => r.profile === p) || {}).exportedCount || 0);
        const analyzedData = labels.map(p => (rows.find(r => r.profile === p) || {}).analyzedCount || 0);
        perSoundTypeData[st] = { labels, exportedData, analyzedData, rows };

        labels.forEach((p, i) => {
          exportedByProfile[p] += exportedData[i];
          analyzedByProfile[p] += analyzedData[i];
        });
      }

      // Focus chart (bar for exported + line for selection rate)
      const focusCtx = document.getElementById('focusChart').getContext('2d');
      let focusChart = new Chart(focusCtx, {
        type: 'bar',
        data: { labels: [], datasets: [] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { beginAtZero: true, title: { display: true, text: 'Exported Count' } },
            y1: { beginAtZero: true, max: 1, position: 'right', grid: { drawOnChartArea: false }, ticks: { callback: v => Math.round(v * 100) + '%' }, title: { display: true, text: 'Selection Rate' } }
          },
          plugins: {
            legend: { position: 'bottom' },
            tooltip: {
              callbacks: {
                afterBody: (items) => {
                  const lab = items[0].label;
                  const st = document.getElementById('soundTypeSelect').value;
                  const rows = perSoundTypeData[st].rows;
                  const m = rows.find(r => r.profile === lab);
                  const exp = perSoundTypeData[st].exportedData[profiles.indexOf(lab)] || 0;
                  const ana = perSoundTypeData[st].analyzedData[profiles.indexOf(lab)] || 0;
                  const rate = ana ? (exp / ana) : 0;
                  const mean = m && m.meanTotal != null ? `, mean total_score=${m.meanTotal.toFixed(3)}` : '';
                  return `Exported=${exp}, Analyzed=${ana}, Rate=${Math.round(rate*100)}%${mean}`;
                }
              }
            }
          }
        }
      });

      function renderSummaryTable(st) {
        const tbody = document.querySelector('#summaryTable tbody');
        const d = perSoundTypeData[st];
        tbody.innerHTML = profiles.map((p, i) => {
          const exp = d.exportedData[i] || 0;
          const ana = d.analyzedData[i] || 0;
          const rate = ana ? Math.round((exp / ana) * 100) : 0;
          return `<tr data-profile="${p}"><td style="text-align:left;">${p}</td><td>${exp}</td><td>${ana}</td><td>${rate}</td></tr>`;
        }).join('');
        tbody.querySelectorAll('tr').forEach(tr => {
          tr.addEventListener('click', () => {
            const prof = tr.dataset.profile;
            const idx = profiles.indexOf(prof);
            focusChart.setActiveElements([{ datasetIndex: 0, index: idx }]);
            focusChart.update();
          });
        });
      }

      function selectSoundType(st) {
        const d = perSoundTypeData[st];
        focusChart.data.labels = d.labels;
        focusChart.data.datasets = [
          {
            label: 'Exported',
            data: d.exportedData,
            backgroundColor: d.labels.map(l => profileColors[l] || '#888'),
            borderWidth: 0,
            yAxisID: 'y'
          },
          {
            type: 'line',
            label: 'Selection Rate',
            data: d.rateData,
            borderColor: '#111827',
            backgroundColor: 'rgba(17,24,39,0.15)',
            tension: 0.25,
            fill: false,
            pointRadius: 3,
            yAxisID: 'y1'
          }
        ];
        focusChart.update();
        renderSummaryTable(st);
      }

      // Selector change
      const sel = document.getElementById('soundTypeSelect');
      sel.addEventListener('change', () => selectSoundType(sel.value));
      sel.value = soundTypes[0];
      selectSoundType(soundTypes[0]);

      // Aggregate (collapsed section) charts
      const agg2 = document.getElementById('aggregateChart2').getContext('2d');
      new Chart(agg2, {
        type: 'bar',
        data: {
          labels: profiles,
          datasets: [{
            label: 'Exported Beams (sum over sound types)',
            data: profiles.map(p => exportedByProfile[p]),
            backgroundColor: profiles.map(p => profileColors[p] || '#888')
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: { y: { beginAtZero: true, title: { display: true, text: 'Count' } } },
          plugins: { legend: { display: false } }
        }
      });

      const cov2 = document.getElementById('coverageChart2').getContext('2d');
      new Chart(cov2, {
        type: 'bar',
        data: {
          labels: profiles,
          datasets: [
            { label: 'Analyzed (all_directions)', data: profiles.map(p => analyzedByProfile[p]), backgroundColor: 'rgba(0,0,0,0.10)' },
            { label: 'Exported (selected)', data: profiles.map(p => exportedByProfile[p]), backgroundColor: profiles.map(p => profileColors[p] || '#888') }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: { y: { beginAtZero: true, title: { display: true, text: 'Count' } } },
          plugins: { legend: { position: 'bottom' } }
        }
      });

      // Keep top aggregate charts for quick glance
      const aggCtx = document.getElementById('aggregateChart').getContext('2d');
      new Chart(aggCtx, {
        type: 'bar',
        data: {
          labels: profiles,
          datasets: [{
            label: 'Exported Beams (sum over sound types)',
            data: profiles.map(p => exportedByProfile[p]),
            backgroundColor: profiles.map(p => profileColors[p] || '#888')
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: { y: { beginAtZero: true, title: { display: true, text: 'Count' } } },
          plugins: { legend: { display: false } }
        }
      });

      const covCtx = document.getElementById('coverageChart').getContext('2d');
      new Chart(covCtx, {
        type: 'bar',
        data: {
          labels: profiles,
          datasets: [
            { label: 'Analyzed (all_directions)', data: profiles.map(p => analyzedByProfile[p]), backgroundColor: 'rgba(0,0,0,0.10)' },
            { label: 'Exported (selected)', data: profiles.map(p => exportedByProfile[p]), backgroundColor: profiles.map(p => profileColors[p] || '#888') }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: { y: { beginAtZero: true, title: { display: true, text: 'Count' } } },
          plugins: { legend: { position: 'bottom' } }
        }
      });

      const aggNote = document.getElementById('aggregateNote');
      aggNote.textContent = 'Totals aggregated across sound types: ' + soundTypes.join(', ') + '.';
    }

    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
